The analysis made in alloy is focus on the relationships between the data, the queries and the individual search made by the clients.

The Query is the most complex concept, the constraints represents logical constraints made on a Parameter, as for example age less than 18 years and so on. Some values will comply that constraint and therefore the user who owns that values will be matched by the query and their data displayed as a result of the query.

Only queries with more than 2 entries are allowed, in the final implementation this level will be raised to 1000. Individual searches are only allowed when a codice matches and the Client already have permission from the user owner of the codice.

\begin{figure}[H]
  \centering
   \includegraphics[width=\textwidth]{Images/world1.png}
  \caption{Example of generated world with 3 Users, 1 Query and 1 Individual Search}
  \label{fig:world1}
\end{figure}

There are several remarkable facts in figure \ref{fig:world1}. As can be saw, the Query only returns the fields that are not protected by privacy issues. In contrast, the Individual Search return all the information of the User matched by the codice since the client have permission. Also, all users have exactly one value of the codice, name and surname and a variable amount of the temporal data as the hearth rate.

\begin{figure}[H]
  \centering
   \includegraphics[width=\textwidth]{Images/world2.png}
  \caption{Example of generated world with only 1 User}
  \label{fig:world2}
\end{figure}

Figure \ref{fig:world2} shows how the Individual Search behaves since the client do not have permission of the user. Therefore the results are empty.

\begin{figure}[H]
  \centering
   \includegraphics[width=\textwidth]{Images/world3.png}
  \caption{Example of generated world with an Individual Search with no results}
  \label{fig:world3}
\end{figure}
Finally \ref{fig:world3} focus on the number of values own by an user. The fixed parameters have, at most one value whilst the temporal ones have zero or more values.

\begin{minted}{alloy}
abstract sig Parameter{}

abstract sig FixedParameter extends Parameter {}
abstract sig TemporalParameter extends Parameter{}

one sig Codice, Name, Surname, Birth, Genre,Residence  extends FixedParameter{}
one sig   Location, Hearthrate, Weight extends TemporalParameter{}

sig Value {}

sig User{}

sig AutomatedSOSUser extends User{}

sig Client{
	permissionOf: set User
}


one sig Database {
	users: set User,
	values: set Value,

	has:  User one -> Value,
	belongs: Value -> one User,


	data:  Value->one Parameter,
	reverse_data :  Parameter one->Value
}{
	belongs = ~ has
	reverse_data =~data

	//1 codice per user
	all u:users |#(has[u] & reverse_data[Codice])=1
	//1 name per user
	all u:users |#(has[u] & reverse_data[Name])=1
	//1 surname per user
	all u:users |#(has[u] & reverse_data[Surname])=1

	//at most 1 residence per user
	all u:users |#(has[u] & reverse_data[Residence])<2
	//at most 1 birth date per user
	all u:users |#(has[u] & reverse_data[Birth])<2
	//at most 1 Genre per user
	all u:users |#(has[u] & reverse_data[Genre])<2
	
}


//All the values and users needs to be stored in the Database
fact {
	all v:Value | v in Database.values
	all u:User | u in Database.users
}


//Values cannot belong to different parameters at the same time
fact{
	all v:Value| one p:Parameter | v->p in Database.data
}

//Values cannot belong to different users at the same time.
fact{
	all v:Value| one u:User | u->v in Database.has
}



sig Query{
	database: one Database,
	
	//Represents the logical constraints inposed by the client in the query
	constraints: set (Location + Hearthrate + Weight + Residence +Birth + Genre),
	//The data that fullfils the constrained imposed.
	results: set Value, 
	//The users that fullfill the constraints imposed
	users_matched: set User 
}{
	//Queries with few entries will not be allowed
	#(users_matched) > 2

	/* The matched users (the one that fullfills the constraints) must have values 
	    for the constrained parameters. However, not all the users  will fullfill the 
	    constraint */
	all u:users_matched | u in database.belongs[database.reverse_data[constraints]]
	
	/* In results all the data of the matched users
	   are present except the protected one.*/
	results = database.has[users_matched] 
	          - database.reverse_data[(Codice + Name + Surname + Residence)]
}

sig IndividualSearch{
	database: one Database,
	codice: one Value,
	result: set Value,
	client: one Client,
}{
	//The codice value must belong to Codice parameter
	database.data[codice] in Codice
	result = database.has[database.belongs[codice] & client.permissionOf]
}

// CHECKS

/* If a user is matched, a constraint has to be made to 
   some parameter in which the user have values stored. */
check noUserMatchedWithoutConstraints{
	all q:Query |{ 
		all u:q.users_matched |u in 
		q.database.belongs[q.database.reverse_data[q.constraints]]
	}
} for 50

//Any codice, name, surname or residence appears in the result of a query.
check noForbiddenParametersInQuery{
	all q:Query | q.database.data[q.results] 
	              not in (Codice + Name + Surname + Residence)
} for 50

//Queries with few entries will not be allowed
check noFewEntries{
	all q:Query | #(q.users_matched)>2
} for 50

//Queries with few entries will not be allowed
check noFewEntries{
	all q:Query | #(q.users_matched)>2
} for 50

//Any user can't have more than 1 codice
check noTwoCodice{
	all d:Database | {
		all u:d.users |#(d.has[u] & d.reverse_data[Codice])<2
	}
} for 50
// Ommited the rest of the checks on numer of genres, residences and so on  for simplicity

//Must be the adequate number of parameters depending of the number of users.
check mandatoryParameters{
		#(Database.users) = #(Database.reverse_data[Codice]) and
		#(Database.users) = #(Database.reverse_data[Name]) and
		#(Database.users) = #(Database.reverse_data[Surname]) and
		#(Database.users) >= #(Database.reverse_data[Birth]) and
		#(Database.users) >= #(Database.reverse_data[Residence]) and
		#(Database.users) >= #(Database.reverse_data[Genre])
} for 50
\end{minted}